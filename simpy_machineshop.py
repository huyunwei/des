"""Machine shop Series System Scenario:  A workshop has *n* identical machines. Each machine runs continuously and it breaks down  periodically. The machines go back to work after repairs are carried out by one repairman. Broken machines  enter the queue of the repairman."""import randomimport simpyRANDOM_SEED = 42MTTF = 3000.0                     # Mean time to failure in minutesREPAIR_TIME = 300.0               # Time it takes to repair a machine in minutesNUM_MACHINES = 1                  # Number of machines in the machine shopWEEKS = 4                         # Simulation time in weeksSIM_TIME = WEEKS * 7 * 24 * 60    # Simulation time in minutesdef time_to_repair():    """return time interval until the repair is done, and machine is ready to run again. """    return REPAIR_TIMEdef time_to_failure():    """Return time until next failure for a machine."""    return random.expovariate(1.0/MTTF)class SystemLog(object):    def __init__(self, name):        self.event_time = []        self.event_sn = []        self.event_type = []        self.down_count = 0class Machine(object):    """A machine produces parts and my get broken every now and then.     If it breaks, it requests a *repairman* and continues the production    after the it is repaired.     A machine has a *name* and a numberof *parts_made* thus far.     """    def __init__(self, env, sn, name, repairman, system_log):        self.env = env        self.sn = sn        self.name = name        self.parts_made = 0        self.broken = False        self.downtime = 0        self.uptime = 0        self.fail = 0         # Start "working" and "break_machine" processes for this machine.        self.process = env.process(self.working(repairman, system_log))        env.process(self.break_machine())     def working(self, repairman, system_log):        """Working as long as the simulation runs.         While working, the machine may break multiple times.        Request a repairman when this happens.         """        while True:            try:                # Working                start = self.env.now                system_log.event_time.append(start)                system_log.event_sn.append(self.sn)                system_log.event_type.append("start")                print("%s starts at %d" % (self.sn, start))                yield self.env.timeout(SIM_TIME)            except simpy.Interrupt:                self.broken = True                self.uptime += self.env.now - start  # How much uptime since last start?                down_start = self.env.now                system_log.event_time.append(down_start)                system_log.event_sn.append(self.sn)                system_log.event_type.append("fail")                print("%s fails at %d" % (self.sn, down_start))                # Request a repairman. This will preempt its "other_job".                with repairman.request(priority=1) as req:                    repair_time = time_to_repair()                    yield req                    yield self.env.timeout(repair_time)                 #Machine back to work                self.broken = False                self.downtime += self.env.now - down_start                self.fail += 1                print("%s starts at %d" % (self.sn, self.env.now))      def break_machine(self):        """Break the machine every now and then. Machine clock continues running even component is down ..."""#        while not self.broken:        while True:            time_to_nextfail = time_to_failure()            print("%s try break at %d + %d" % (self.sn, self.env.now, time_to_nextfail))               yield self.env.timeout(time_to_nextfail)            if not self.broken:                # Only break the machine if it is currently working.                self.process.interrupt()            else: print("%s skip fail at %d" % (self.sn, self.env.now))  # Setup and start the simulationprint('Machine shop Series')random.seed(RANDOM_SEED)  # This helps reproducing the results # Create an environment and start the setup processenv = simpy.Environment()repairman = simpy.PreemptiveResource(env, capacity=1)system_log = SystemLog("series_system")machines = [Machine(env, 'Machine %d' % i, "dummy", repairman, system_log)            for i in range(NUM_MACHINES)]# Execute!env.run(until=SIM_TIME) # Analyis/resultsprint('Machine shop results after %s weeks' % WEEKS)for machine in machines:    print('%s failed %d times.' % (machine.sn, machine.fail))